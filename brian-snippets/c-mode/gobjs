# -*- mode: snippet -*-
#name: gobjc
#key: gobjc
# --
/*
 * Copyright information
 */

#include "maman-bar.h"

/* If you use Pimpls, include the private structure 
 * definition here. Some people create a maman-bar-private.h header
 * which is included by the maman-bar.c file and which contains the
 * definition for this private structure.
 */

#define MAMAN_BAR_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), MAMAN_TYPE_BAR, MamanBarPrivate))

struct _MamanBarPrivate
{
  GObject *an_object;

  gchar *a_string;
};

G_DEFINE_TYPE (MamanBar, maman_bar, G_TYPE_OBJECT);

/* 
 * forward definitions
 */

static void
maman_bar_init (MamanBar *self)
{
  self->priv = MAMAN_BAR_GET_PRIVATE (self); 

  /* initialize all public and private members to reasonable default values. */

  /* If you need specific construction properties to complete initialization,
   * delay initialization completion until the property is set. 
   */
}

static void
bar_class_init (MamanBarClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
  GParamSpec *pspec;

  gobject_class->set_property = bar_set_property;
  gobject_class->get_property = bar_get_property;

  pspec = g_param_spec_string ("maman",
                                          "Maman construct prop",
                                          "Set maman's name",
                                          "no-name-set" /* default value */,
                                          G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE);
  g_object_class_install_property (gobject_class,
                                   PROP_MAMAN,
                                   pspec);
}

static void
maman_bar_dispose (GObject *gobject)
{
  MamanBar *self = MAMAN_BAR (gobject);

  /* 
   * In dispose, you are supposed to free all types referenced from this
   * object which might themselves hold a reference to self. Generally,
   * the most simple solution is to unref all members on which you own a 
   * reference.
   */

  /* dispose might be called multiple times, so we must guard against
   * calling g_object_unref() on an invalid GObject.
   */
   /*
  if (self->priv->an_object) {
      g_object_unref (self->priv->an_object);

      self->priv->an_object = NULL;
      }
    */
  /* Chain up to the parent class */
  G_OBJECT_CLASS (maman_bar_parent_class)->dispose (gobject);
}

static void
maman_bar_finalize (GObject *gobject)
{
  MamanBar *self = MAMAN_BAR (gobject);

  g_free (self->priv->a_string);

  /* Chain up to the parent class */
  G_OBJECT_CLASS (maman_bar_parent_class)->finalize (gobject);
}

static void
maman_bar_class_init (MamanBarClass *klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);

  gobject_class->dispose = maman_bar_dispose;
  gobject_class->finalize = maman_bar_finalize;

  g_type_class_add_private (klass, sizeof (MamanBarPrivate));
}

static void
maman_bar_init (MamanBar *self);
{
  self->priv = MAMAN_BAR_GET_PRIVATE (self);

  self->priv->an_object = g_object_new (MAMAN_TYPE_BAZ, NULL);
  self->priv->a_string = g_strdup ("Maman");
}
$0

MamanBar *
maman_bar_new ()
{
  return g_object_new (MAMAN_TYPE_BAR,
  	 NULL);
}
